name: Retrieve Kubernetes OpenAPI Spec using minikube (hardened action)

on:
  workflow_dispatch:
    inputs:
      go_version:
        description: "Go Version (format: X.Y.Z, e.g., 1.20.6)"
        required: true
        default: "1.20.6"
        type: string

# Explicitly declare minimum required permissions
permissions:
  contents: write
  actions: read

# Environment variables for pinned dependency versions
env:
  CRI_DOCKERD_VERSION: "0.3.17"
  MINIKUBE_VERSION: "1.35.0"

jobs:
  fetch-versions:
    runs-on: ubuntu-latest
    outputs:
      versions_list: ${{ steps.fetch_data_versions.outputs.versions_array }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Fetch and process versions
        id: fetch_data_versions
        run: |
          # Fetch releases and get latest patch for each minor version, then take top 3
          versions=$(curl -s "https://api.github.com/repos/kubernetes/kubernetes/releases?per_page=100" \
            | jq -r '
              [.[] | select(.prerelease == false and .draft == false) | .tag_name]
              | map(select(test("^v[0-9]+\\.[0-9]+\\.[0-9]+$")))
              | group_by((split(".")[0:2]) | join("."))
              | map(sort_by(split(".")[2] | tonumber) | last)
              | sort_by([(split(".")[0] | ltrimstr("v") | tonumber), (split(".")[1] | tonumber)])
              | reverse
              | .[0:3]
              | .[]
            ')

          # Fallback if no versions are fetched
          if [[ -z "$versions" ]]; then
            echo "No versions fetched, setting default values."
            versions="v1.35.0 v1.34.3 v1.33.1"
          fi

          # Validate each version strictly matches semantic versioning
          for version in $versions; do
            if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid version format detected: $version"
              exit 1
            fi
          done

          # Debugging
          echo "Fetched versions: $versions"

          # Write to versions.txt for debugging
          echo "$versions" > versions.txt

          # Convert newline-separated list to JSON array
          mapfile -t version_array < versions.txt
          json_array=$(printf '%s\n' "${version_array[@]}" | jq -R . | jq -s .)

          # Validate JSON array
          echo "$json_array" | jq . || { echo "Error: Invalid JSON array"; exit 1; }

          # Trim any leading/trailing whitespace from the JSON array
          json_array=$(echo "$json_array" | sed 's/^[ \t]*//;s/[ \t]*$//')

          # Ensure the JSON is compact and has no trailing commas
          json_array=$(echo "$json_array" | jq -c .)

          # Wrap the array with the desired key structure
          final_output=$(echo "{\"kubernetes-version\": $json_array}")

          # Write the JSON object to GITHUB_OUTPUT
          echo "versions_array=$final_output" >> $GITHUB_OUTPUT

  manage_folder_versions:
    needs: fetch-versions
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Fetch and process versions from previous job
        id: fetch_and_compare_versions
        run: |
          # Extract versions from the previous job output.
          echo '${{ needs.fetch-versions.outputs.versions_list }}' > version_input.json
          
          # Validate JSON before processing
          jq . version_input.json > /dev/null || { echo "ERROR: Invalid JSON from previous job"; exit 1; }
          
          readarray -t latest_versions <<< "$(jq -r '.["kubernetes-version"][]' version_input.json)"

          # Validate all fetched versions
          for version in "${latest_versions[@]}"; do
            if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid version format in latest_versions: $version"
              exit 1
            fi
          done

          # List directories representing Kubernetes versions in the repository
          # Only match valid version directories
          readarray -t current_versions <<< "$(ls -1d v[0-9]*.[0-9]*.[0-9]*/ 2>/dev/null | sed 's/\/$//' | sort -V)"
          
          echo "Current repository folders:"
          printf '%s\n' "${current_versions[@]}"
          echo "Latest fetched versions:"
          printf '%s\n' "${latest_versions[@]}"

          changes_made=false

          # Function to compare versions
          compare_versions() {
              local version1="${1:1}"
              local version2="${2:1}"

              IFS='.' read -r -a ver1 <<< "$version1"
              IFS='.' read -r -a ver2 <<< "$version2"

              for i in {0..2}; do
                  if (( ${ver1[i]:-0} > ${ver2[i]:-0} )); then
                      case $i in
                          0) echo "1"; return ;;
                          1) echo "2"; return ;;
                          2) echo "3"; return ;;
                      esac
                  elif (( ${ver1[i]:-0} < ${ver2[i]:-0} )); then
                      case $i in
                          0) echo "-1"; return ;;
                          1) echo "-2"; return ;;
                          2) echo "-3"; return ;;
                      esac
                  fi
              done

              echo "0"
          }

          # Step 1: Deprecate the oldest version if a newer major.minor version exists
          if [[ ${#current_versions[@]} -gt 0 && -n "${current_versions[0]}" ]]; then
              oldest_version=${current_versions[0]}
              echo "Oldest current version: $oldest_version"

              newest_current_version=${current_versions[-1]}
              echo "Newest current version: $newest_current_version"

              newest_fetched_version=${latest_versions[0]}
              echo "Newest fetched version: $newest_fetched_version"

              result=$(compare_versions "${newest_fetched_version}" "${newest_current_version}")
              echo "Comparing newest_fetched_version=${newest_fetched_version} with newest_current_version=${newest_current_version} (result: $result)"

              if [[ $result -eq 1 || $result -eq 2 ]]; then
                  echo "Deprecating the oldest version: ${oldest_version}"
                  if [[ -d "$oldest_version" ]]; then
                      mkdir -p deprecated
                      mv "$oldest_version" "deprecated/$oldest_version" || {
                          echo "Failed to move ${oldest_version} to deprecated/"
                          exit 1
                      }
                      changes_made=true
                  else
                      echo "Folder $oldest_version does not exist."
                      exit 1
                  fi
              fi
          fi

          # Step 2: Remove outdated patch versions
          if [[ "$changes_made" == true ]]; then
              remaining_current_versions=("${current_versions[@]:1}")
              remaining_fetched_versions=("${latest_versions[@]:1}")

              for (( idx=${#remaining_current_versions[@]}-1 ; idx>=0 ; idx-- )); do
                  idxn=$(( ${#remaining_fetched_versions[@]} - idx - 1 ))
                  result=$(compare_versions "${remaining_fetched_versions[idxn]}" "${remaining_current_versions[idx]}")
                  echo "Debug: idx=$idx, idxn=$idxn"
                  echo "Comparing ${remaining_fetched_versions[idxn]} with ${remaining_current_versions[idx]} (result: $result)"

                  if [[ $result -eq 3 || $result -eq 0 ]]; then
                      echo "Removing outdated patch version: ${remaining_current_versions[idx]}"
                      rm -rf "${remaining_current_versions[idx]}" || {
                          echo "Failed to remove ${remaining_current_versions[idx]}"
                          exit 1
                      }
                      changes_made=true
                  fi
              done
          else
              for (( idx=${#current_versions[@]}-1 ; idx>=0 ; idx-- )); do
                  idxn=$(( ${#latest_versions[@]} - idx - 1 ))
                  result=$(compare_versions "${latest_versions[idxn]}" "${current_versions[idx]}")
                  echo "Debug: idx=$idx, idxn=$idxn"
                  echo "Comparing ${latest_versions[idxn]} with ${current_versions[idx]} (result: $result)"

                  if [[ $result -eq 3 || $result -eq 0 ]]; then
                      echo "Removing outdated patch version: ${current_versions[idx]}"
                      rm -rf "${current_versions[idx]}" || {
                          echo "Failed to remove ${current_versions[idx]}"
                          exit 1
                      }
                      changes_made=true
                  fi
              done
          fi

          if [[ "$changes_made" == true ]]; then
              echo "Changes have been made."
          else
              echo "No changes were necessary."
          fi

          echo "changes_made=$changes_made" >> $GITHUB_ENV

      - name: Debug changes after manage_folder_versions
        run: |
          echo "Listing directories after manage_folder_versions step:"
          ls -la
          echo "Current Git status:"
          git status

      - name: Commit and push changes
        if: env.changes_made == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add .
          git commit -m "Manage folder versions: Added/removed directories"
          git push origin main

  build_and_run:
    needs: [fetch-versions, manage_folder_versions]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.fetch-versions.outputs.versions_list) }}
    steps:
      - name: Check out code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # Validate Kubernetes version from matrix
      - name: Validate Kubernetes version
        id: validate_k8s
        run: |
          K8S_VERSION="${{ matrix.kubernetes-version }}"
          if [[ ! "$K8S_VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid Kubernetes version format: $K8S_VERSION"
            exit 1
          fi
          echo "version=$K8S_VERSION" >> $GITHUB_OUTPUT
          echo "Validated Kubernetes version: $K8S_VERSION"

      # Validate Go version input and install with checksum verification
      - name: Validate and install Go
        run: |
          GO_VERSION="${{ github.event.inputs.go_version }}"
          
          # Strict validation: only allow expected format (X.Y.Z)
          if [[ ! "$GO_VERSION" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
            echo "ERROR: Invalid Go version format. Expected: X.Y.Z (e.g., 1.20.6)"
            exit 1
          fi
          
          echo "Installing Go version: $GO_VERSION"
          
          # Download Go
          wget -q "https://golang.org/dl/go${GO_VERSION}.linux-amd64.tar.gz"
          
          # Fetch and verify checksum
          EXPECTED_SHA=$(curl -sL "https://go.dev/dl/?mode=json&include=all" | \
            jq -r ".[] | select(.version==\"go${GO_VERSION}\") | .files[] | select(.filename==\"go${GO_VERSION}.linux-amd64.tar.gz\") | .sha256")
          
          if [[ -z "$EXPECTED_SHA" || "$EXPECTED_SHA" == "null" ]]; then
            echo "WARNING: Could not fetch checksum from Go API, attempting download anyway"
          else
            echo "Verifying checksum..."
            echo "${EXPECTED_SHA}  go${GO_VERSION}.linux-amd64.tar.gz" | sha256sum -c - || {
              echo "ERROR: Checksum verification failed!"
              exit 1
            }
          fi
          
          sudo tar -C /usr/local -xzf "go${GO_VERSION}.linux-amd64.tar.gz"
          echo "/usr/local/go/bin" >> $GITHUB_PATH
          echo "Go installed successfully."

      # Clone cri-dockerd at pinned version
      - name: Clone cri-dockerd repository
        run: |
          echo "Cloning cri-dockerd version: v${{ env.CRI_DOCKERD_VERSION }}"
          git clone --branch "v${{ env.CRI_DOCKERD_VERSION }}" --depth 1 \
            https://github.com/Mirantis/cri-dockerd.git

      - name: Build cri-dockerd
        run: |
          cd cri-dockerd
          mkdir bin
          /usr/local/go/bin/go get && /usr/local/go/bin/go build -o bin/cri-dockerd
          sudo mkdir -p /usr/local/bin
          sudo install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd
          echo "cri-dockerd built successfully."

      - name: Set up systemd for cri-dockerd
        run: |
          sudo cp -a cri-dockerd/packaging/systemd/* /etc/systemd/system
          sudo sed -i -e 's,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,' /etc/systemd/system/cri-docker.service
          sudo systemctl daemon-reload
          sudo systemctl enable cri-docker.service
          sudo systemctl enable --now cri-docker.socket
          echo "cri-dockerd systemd configuration set."

      - name: Install Docker and containerd
        run: |
          sudo apt-get update
          sudo apt-get remove -y containerd.io || true
          sudo apt-get install -y docker.io docker-compose
          sudo apt-get autoremove -y
          echo "Docker and Containerd installed."

      # Install minikube with checksum verification
      - name: Install Minikube
        run: |
          echo "Installing minikube version: v${{ env.MINIKUBE_VERSION }}"
          
          curl -LO "https://storage.googleapis.com/minikube/releases/v${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64"
          curl -LO "https://storage.googleapis.com/minikube/releases/v${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64.sha256"
          
          # Verify checksum
          echo "$(cat minikube-linux-amd64.sha256)  minikube-linux-amd64" | sha256sum -c - || {
            echo "ERROR: Minikube checksum verification failed!"
            exit 1
          }
          
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          echo "Minikube installed successfully."

      - name: Start Minikube
        run: |
          # Use validated version from earlier step
          K8S_VERSION="${{ steps.validate_k8s.outputs.version }}"
          echo "Starting minikube with Kubernetes version: $K8S_VERSION"
          
          minikube start --kubernetes-version="${K8S_VERSION}" --driver=docker
          
          # Verify cluster is running
          kubectl cluster-info || {
            echo "ERROR: Cluster failed to start properly"
            minikube logs
            exit 1
          }

      - name: Get OpenAPI Spec
        run: |
          K8S_VERSION="${{ steps.validate_k8s.outputs.version }}"
          mkdir -p "${K8S_VERSION}"
          
          kubectl get --raw /openapi/v2 > "${K8S_VERSION}/spec.json"
          
          # Validate output is valid JSON
          jq empty "${K8S_VERSION}/spec.json" || {
            echo "ERROR: Invalid JSON in OpenAPI spec"
            exit 1
          }
          
          # Basic sanity check - ensure it has expected OpenAPI structure
          if ! jq -e '.swagger or .openapi' "${K8S_VERSION}/spec.json" > /dev/null; then
            echo "ERROR: spec.json doesn't appear to be a valid OpenAPI document"
            exit 1
          fi
          
          echo "OpenAPI spec retrieved and validated successfully."

      - name: Upload OpenAPI specs
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: specs-${{ steps.validate_k8s.outputs.version }}
          path: ${{ steps.validate_k8s.outputs.version }}/spec.json
          retention-days: 1

      - name: Stop and delete Minikube cluster
        if: always()
        run: |
          minikube stop || true
          minikube delete --all || true

  commit_changes:
    needs: build_and_run
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Pull latest changes from remote
        run: |
          git pull origin main

      - name: Download all OpenAPI specs
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: specs

      - name: Move specs to proper folders
        run: |
          for spec_dir in specs/specs-*; do
            if [[ -d "$spec_dir" ]]; then
              folder_name=$(basename "$spec_dir" | sed 's/specs-//')
              
              # Validate folder name matches version format
              if [[ ! "$folder_name" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "WARNING: Skipping invalid folder name: $folder_name"
                continue
              fi
              
              mkdir -p "$folder_name"
              mv "${spec_dir}/spec.json" "${folder_name}/"
              
              # Validate moved file
              jq empty "${folder_name}/spec.json" || {
                echo "ERROR: Invalid JSON in ${folder_name}/spec.json"
                exit 1
              }
            fi
          done
          
          # Clean up specs directory
          rm -rf specs

      - name: Create schema subfolder and clone repository
        run: |
          for folder_name in v*; do
            if [[ -d "$folder_name" && "$folder_name" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Processing schema for: $folder_name"
              
              mkdir -p "${folder_name}/schema"
              
              # Clone with depth 1 for efficiency
              if git clone --depth 1 https://github.com/yannh/kubernetes-json-schema.git "tmp-${folder_name}" 2>/dev/null; then
                # Only copy if the version directory exists in the schema repo
                if [[ -d "tmp-${folder_name}/${folder_name}" ]]; then
                  cp -r "tmp-${folder_name}/${folder_name}/"* "${folder_name}/schema/"
                  echo "Schema copied for ${folder_name}"
                else
                  echo "WARNING: No schema found for ${folder_name} in kubernetes-json-schema"
                fi
                rm -rf "tmp-${folder_name}"
              else
                echo "WARNING: Failed to clone kubernetes-json-schema for ${folder_name}"
              fi
            fi
          done

      - name: Commit and push changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add .
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Add OpenAPI specs for Kubernetes versions"
            git push origin main
          fi
